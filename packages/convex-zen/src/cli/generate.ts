import { access, mkdir, readFile, rm, writeFile } from "node:fs/promises";
import path from "node:path";

const GENERATED_MARKER = "// @generated by convex-zen generate. DO NOT EDIT.";

export interface GenerateOptions {
  cwd: string;
  check: boolean;
  verbose: boolean;
}

export interface GenerateResult {
  created: string[];
  updated: string[];
  deleted: string[];
  unchanged: string[];
  warnings: string[];
}

type GeneratedFile = {
  absolutePath: string;
  relativePath: string;
  content: string;
};

function normalizeContent(content: string): string {
  return content.endsWith("\n") ? content : `${content}\n`;
}

async function fileExists(filePath: string): Promise<boolean> {
  try {
    await access(filePath);
    return true;
  } catch {
    return false;
  }
}

function isGeneratedFile(content: string): boolean {
  return content.startsWith(GENERATED_MARKER);
}

function detectEnabledPlugins(indexSource: string): Set<string> {
  const plugins = new Set<string>();
  if (/adminPlugin\s*\(/.test(indexSource)) {
    plugins.add("admin");
  }
  return plugins;
}

function renderCoreFile(): string {
  return normalizeContent(`${GENERATED_MARKER}
import { v } from "convex/values";
import { action } from "../_generated/server";
import { auth } from "./index";

export const signUp = action({
  args: {
    email: v.string(),
    password: v.string(),
    name: v.optional(v.string()),
    ipAddress: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    return auth.signUp(ctx, args);
  },
});

export const signInWithEmail = action({
  args: {
    email: v.string(),
    password: v.string(),
    ipAddress: v.optional(v.string()),
    userAgent: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    return auth.signIn(ctx, args);
  },
});

export const verifyEmail = action({
  args: {
    email: v.string(),
    code: v.string(),
  },
  handler: async (ctx, args) => {
    return auth.verifyEmail(ctx, args);
  },
});

export const requestPasswordReset = action({
  args: {
    email: v.string(),
    ipAddress: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    return auth.requestPasswordReset(ctx, args);
  },
});

export const resetPassword = action({
  args: {
    email: v.string(),
    code: v.string(),
    newPassword: v.string(),
  },
  handler: async (ctx, args) => {
    return auth.resetPassword(ctx, args);
  },
});

export const signOut = action({
  args: {
    token: v.string(),
  },
  handler: async (ctx, args) => {
    await auth.signOut(ctx, args.token);
  },
});

export const validateSession = action({
  args: {
    token: v.string(),
  },
  handler: async (ctx, args) => {
    return auth.session.validate(ctx, args.token);
  },
});

export const currentUser = action({
  args: {
    token: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    return auth.user.safeGet(ctx, args.token);
  },
});

export const getOAuthUrl = action({
  args: {
    providerId: v.string(),
    redirectUrl: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    return auth.getOAuthUrl(ctx, args.providerId, args.redirectUrl);
  },
});

export const handleOAuthCallback = action({
  args: {
    providerId: v.string(),
    code: v.string(),
    state: v.string(),
    redirectUrl: v.optional(v.string()),
    ipAddress: v.optional(v.string()),
    userAgent: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    return auth.handleCallback(ctx, args);
  },
});
`);
}

function renderAdminFile(): string {
  return normalizeContent(`${GENERATED_MARKER}
import { v } from "convex/values";
import { action } from "../_generated/server";
import { auth } from "./index";

export const listUsers = action({
  args: {
    token: v.optional(v.string()),
    limit: v.optional(v.number()),
    cursor: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    if (!auth.admin) {
      throw new Error("Admin plugin is not enabled");
    }
    return auth.admin.listUsers(ctx, args);
  },
});

export const banUser = action({
  args: {
    token: v.optional(v.string()),
    userId: v.string(),
    reason: v.optional(v.string()),
    expiresAt: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    if (!auth.admin) {
      throw new Error("Admin plugin is not enabled");
    }
    return auth.admin.banUser(ctx, args);
  },
});

export const unbanUser = action({
  args: {
    token: v.optional(v.string()),
    userId: v.string(),
  },
  handler: async (ctx, args) => {
    if (!auth.admin) {
      throw new Error("Admin plugin is not enabled");
    }
    return auth.admin.unbanUser(ctx, args);
  },
});

export const setRole = action({
  args: {
    token: v.optional(v.string()),
    userId: v.string(),
    role: v.string(),
  },
  handler: async (ctx, args) => {
    if (!auth.admin) {
      throw new Error("Admin plugin is not enabled");
    }
    return auth.admin.setRole(ctx, args);
  },
});

export const deleteUser = action({
  args: {
    token: v.optional(v.string()),
    userId: v.string(),
  },
  handler: async (ctx, args) => {
    if (!auth.admin) {
      throw new Error("Admin plugin is not enabled");
    }
    return auth.admin.deleteUser(ctx, args);
  },
});
`);
}

async function upsertGeneratedFile(
  file: GeneratedFile,
  options: GenerateOptions,
  result: GenerateResult
): Promise<void> {
  const exists = await fileExists(file.absolutePath);
  if (!exists) {
    if (options.check) {
      result.updated.push(file.relativePath);
      return;
    }
    await mkdir(path.dirname(file.absolutePath), { recursive: true });
    await writeFile(file.absolutePath, file.content, "utf8");
    result.created.push(file.relativePath);
    return;
  }

  const existing = await readFile(file.absolutePath, "utf8");
  if (!isGeneratedFile(existing)) {
    throw new Error(
      `Refusing to overwrite non-generated file: ${file.relativePath}`
    );
  }

  if (existing === file.content) {
    result.unchanged.push(file.relativePath);
    return;
  }

  if (options.check) {
    result.updated.push(file.relativePath);
    return;
  }

  await writeFile(file.absolutePath, file.content, "utf8");
  result.updated.push(file.relativePath);
}

async function deleteGeneratedFileIfExists(
  absolutePath: string,
  relativePath: string,
  options: GenerateOptions,
  result: GenerateResult
): Promise<void> {
  if (!(await fileExists(absolutePath))) {
    return;
  }
  const existing = await readFile(absolutePath, "utf8");
  if (!isGeneratedFile(existing)) {
    throw new Error(`Refusing to delete non-generated file: ${relativePath}`);
  }
  if (options.check) {
    result.deleted.push(relativePath);
    return;
  }
  await rm(absolutePath);
  result.deleted.push(relativePath);
}

export async function generateAuthFunctions(
  options: GenerateOptions
): Promise<GenerateResult> {
  const result: GenerateResult = {
    created: [],
    updated: [],
    deleted: [],
    unchanged: [],
    warnings: [],
  };

  const authDir = path.join(options.cwd, "convex", "auth");
  const indexPath = path.join(authDir, "index.ts");

  if (!(await fileExists(indexPath))) {
    throw new Error(
      `Missing auth source file at ${path.relative(options.cwd, indexPath)}`
    );
  }

  const indexSource = await readFile(indexPath, "utf8");
  const enabledPlugins = detectEnabledPlugins(indexSource);

  if (!/export\s+const\s+authOptions\s*=/.test(indexSource)) {
    result.warnings.push(
      "authOptions export was not found in convex/auth/index.ts (recommended for generator compatibility)."
    );
  }

  const filesToGenerate: GeneratedFile[] = [
    {
      absolutePath: path.join(authDir, "core.ts"),
      relativePath: path.join("convex", "auth", "core.ts"),
      content: renderCoreFile(),
    },
  ];

  if (enabledPlugins.has("admin")) {
    filesToGenerate.push({
      absolutePath: path.join(authDir, "admin.ts"),
      relativePath: path.join("convex", "auth", "admin.ts"),
      content: renderAdminFile(),
    });
  }

  for (const file of filesToGenerate) {
    await upsertGeneratedFile(file, options, result);
  }

  if (!enabledPlugins.has("admin")) {
    await deleteGeneratedFileIfExists(
      path.join(authDir, "admin.ts"),
      path.join("convex", "auth", "admin.ts"),
      options,
      result
    );
  }

  return result;
}
