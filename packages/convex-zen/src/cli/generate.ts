import {
  access,
  mkdir,
  readFile,
  readdir,
  rm,
  writeFile,
} from "node:fs/promises";
import path from "node:path";

const GENERATED_MARKER = "// @generated by convex-zen generate. DO NOT EDIT.";

export interface GenerateOptions {
  cwd: string;
  check: boolean;
  verbose: boolean;
}

export interface GenerateResult {
  created: string[];
  updated: string[];
  deleted: string[];
  unchanged: string[];
  warnings: string[];
}

type GeneratedFile = {
  absolutePath: string;
  relativePath: string;
  content: string;
};

type PluginFunctionKind = "query" | "mutation" | "action";
type PluginFunctionMeta = Record<string, Record<string, PluginFunctionKind>>;
type AuthSourceLayout = "zen" | "root" | "index";

type ResolvedAuthSource = {
  absolutePath: string;
  relativePath: string;
  layout: AuthSourceLayout;
  coreAuthImportPath: string;
  pluginAuthImportPath: string;
};

function normalizeContent(content: string): string {
  return content.endsWith("\n") ? content : `${content}\n`;
}

async function fileExists(filePath: string): Promise<boolean> {
  try {
    await access(filePath);
    return true;
  } catch {
    return false;
  }
}

function isGeneratedFile(content: string): boolean {
  return content.startsWith(GENERATED_MARKER);
}

async function resolveAuthSource(cwd: string): Promise<ResolvedAuthSource | null> {
  const zenPath = path.join(cwd, "convex", "zenConvex.ts");
  if (await fileExists(zenPath)) {
    return {
      absolutePath: zenPath,
      relativePath: path.join("convex", "zenConvex.ts"),
      layout: "zen",
      coreAuthImportPath: "../zenConvex",
      pluginAuthImportPath: "../../zenConvex",
    };
  }

  const rootPath = path.join(cwd, "convex", "auth.ts");
  if (await fileExists(rootPath)) {
    return {
      absolutePath: rootPath,
      relativePath: path.join("convex", "auth.ts"),
      layout: "root",
      coreAuthImportPath: "../auth",
      pluginAuthImportPath: "../../auth",
    };
  }

  const indexPath = path.join(cwd, "convex", "auth", "index.ts");
  if (await fileExists(indexPath)) {
    return {
      absolutePath: indexPath,
      relativePath: path.join("convex", "auth", "index.ts"),
      layout: "index",
      coreAuthImportPath: ".",
      pluginAuthImportPath: "..",
    };
  }

  return null;
}

function detectEnabledPlugins(authSource: string): Set<string> {
  const plugins = new Set<string>();
  if (/adminPlugin\s*\(/.test(authSource)) {
    plugins.add("admin");
  }
  return plugins;
}

function hasOAuthProviders(authSource: string): boolean {
  return (
    /\bproviders\s*:\s*\[/.test(authSource) ||
    /\bgoogleProvider\s*\(/.test(authSource) ||
    /\bgithubProvider\s*\(/.test(authSource)
  );
}

function renderCoreFile(options: {
  includeOAuth: boolean;
  authImportPath: string;
}): string {
  const serverImports = options.includeOAuth ? "action, mutation" : "mutation";
  const authImportPath = options.authImportPath;
  const oauthExports = options.includeOAuth
    ? `
export const getOAuthUrl = action({
  args: {
    providerId: v.string(),
    redirectUrl: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    return auth.getOAuthUrl(ctx, args.providerId, args.redirectUrl);
  },
});

export const handleOAuthCallback = action({
  args: {
    providerId: v.string(),
    code: v.string(),
    state: v.string(),
    redirectUrl: v.optional(v.string()),
    ipAddress: v.optional(v.string()),
    userAgent: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    return auth.handleCallback(ctx, args);
  },
});
`
    : "";

  return normalizeContent(`${GENERATED_MARKER}
import { v } from "convex/values";
import { ${serverImports} } from "../_generated/server";
import { auth } from "${authImportPath}";

export const signUp = mutation({
  args: {
    email: v.string(),
    password: v.string(),
    name: v.optional(v.string()),
    ipAddress: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    return auth.signUp(ctx, args);
  },
});

export const signInWithEmail = mutation({
  args: {
    email: v.string(),
    password: v.string(),
    ipAddress: v.optional(v.string()),
    userAgent: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    return auth.signIn(ctx, args);
  },
});

export const verifyEmail = mutation({
  args: {
    email: v.string(),
    code: v.string(),
  },
  handler: async (ctx, args) => {
    return auth.verifyEmail(ctx, args);
  },
});

export const requestPasswordReset = mutation({
  args: {
    email: v.string(),
    ipAddress: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    return auth.requestPasswordReset(ctx, args);
  },
});

export const resetPassword = mutation({
  args: {
    email: v.string(),
    code: v.string(),
    newPassword: v.string(),
  },
  handler: async (ctx, args) => {
    return auth.resetPassword(ctx, args);
  },
});

export const signOut = mutation({
  args: {
    token: v.string(),
  },
  handler: async (ctx, args) => {
    await auth.signOut(ctx, args.token);
  },
});

export const validateSession = mutation({
  args: {
    token: v.string(),
  },
  handler: async (ctx, args) => {
    return auth.session.validate(ctx, args.token);
  },
});

export const currentUser = mutation({
  args: {
    token: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    return auth.user.safeGet(ctx, args.token);
  },
});

${oauthExports}
`);
}

function renderAdminPluginFile(options: { authImportPath: string }): string {
  const authImportPath = options.authImportPath;
  return normalizeContent(`${GENERATED_MARKER}
import { v } from "convex/values";
import { mutation, query } from "../../_generated/server";
import { auth } from "${authImportPath}";

export const isAdmin = query({
  args: {},
  handler: async (ctx) => {
    if (!auth.admin) {
      throw new Error("Admin plugin is not enabled");
    }
    return auth.admin.isAdmin(ctx);
  },
});

export const listUsers = query({
  args: {
    limit: v.optional(v.number()),
    cursor: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    if (!auth.admin) {
      throw new Error("Admin plugin is not enabled");
    }
    return auth.admin.listUsers(ctx, args);
  },
});

export const banUser = mutation({
  args: {
    userId: v.string(),
    reason: v.optional(v.string()),
    expiresAt: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    if (!auth.admin) {
      throw new Error("Admin plugin is not enabled");
    }
    return auth.admin.banUser(ctx, args);
  },
});

export const unbanUser = mutation({
  args: {
    userId: v.string(),
  },
  handler: async (ctx, args) => {
    if (!auth.admin) {
      throw new Error("Admin plugin is not enabled");
    }
    return auth.admin.unbanUser(ctx, args);
  },
});

export const setRole = mutation({
  args: {
    userId: v.string(),
    role: v.string(),
  },
  handler: async (ctx, args) => {
    if (!auth.admin) {
      throw new Error("Admin plugin is not enabled");
    }
    return auth.admin.setRole(ctx, args);
  },
});

export const deleteUser = mutation({
  args: {
    userId: v.string(),
  },
  handler: async (ctx, args) => {
    if (!auth.admin) {
      throw new Error("Admin plugin is not enabled");
    }
    return auth.admin.deleteUser(ctx, args);
  },
});
`);
}

function parsePluginFunctionKinds(source: string): Record<string, PluginFunctionKind> {
  const result: Record<string, PluginFunctionKind> = {};
  const pattern = /export\s+const\s+([A-Za-z0-9_]+)\s*=\s*(query|mutation|action)\s*\(/g;
  let match = pattern.exec(source);
  while (match) {
    const functionName = match[1];
    const functionKind = match[2] as PluginFunctionKind;
    if (functionName) {
      result[functionName] = functionKind;
    }
    match = pattern.exec(source);
  }
  return result;
}

function renderPluginMetaFile(pluginMeta: PluginFunctionMeta): string {
  const normalizedEntries = Object.entries(pluginMeta)
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([pluginName, functions]) => {
      const sortedFunctions = Object.fromEntries(
        Object.entries(functions).sort(([a], [b]) => a.localeCompare(b))
      );
      return [pluginName, sortedFunctions] as const;
    });
  const normalizedMeta = Object.fromEntries(normalizedEntries);

  return normalizeContent(`${GENERATED_MARKER}
export const authPluginMeta = ${JSON.stringify(normalizedMeta, null, 2)} as const;

export type AuthPluginMeta = typeof authPluginMeta;
`);
}

async function upsertGeneratedFile(
  file: GeneratedFile,
  options: GenerateOptions,
  result: GenerateResult
): Promise<void> {
  const exists = await fileExists(file.absolutePath);
  if (!exists) {
    if (options.check) {
      result.updated.push(file.relativePath);
      return;
    }
    await mkdir(path.dirname(file.absolutePath), { recursive: true });
    await writeFile(file.absolutePath, file.content, "utf8");
    result.created.push(file.relativePath);
    return;
  }

  const existing = await readFile(file.absolutePath, "utf8");
  if (!isGeneratedFile(existing)) {
    throw new Error(
      `Refusing to overwrite non-generated file: ${file.relativePath}`
    );
  }

  if (existing === file.content) {
    result.unchanged.push(file.relativePath);
    return;
  }

  if (options.check) {
    result.updated.push(file.relativePath);
    return;
  }

  await writeFile(file.absolutePath, file.content, "utf8");
  result.updated.push(file.relativePath);
}

async function deleteGeneratedFileIfExists(
  absolutePath: string,
  relativePath: string,
  options: GenerateOptions,
  result: GenerateResult
): Promise<void> {
  if (!(await fileExists(absolutePath))) {
    return;
  }
  const existing = await readFile(absolutePath, "utf8");
  if (!isGeneratedFile(existing)) {
    throw new Error(`Refusing to delete non-generated file: ${relativePath}`);
  }
  if (options.check) {
    result.deleted.push(relativePath);
    return;
  }
  await rm(absolutePath);
  result.deleted.push(relativePath);
}

export async function generateAuthFunctions(
  options: GenerateOptions
): Promise<GenerateResult> {
  const result: GenerateResult = {
    created: [],
    updated: [],
    deleted: [],
    unchanged: [],
    warnings: [],
  };

  const authDir = path.join(options.cwd, "convex", "auth");
  const pluginDir = path.join(authDir, "plugin");
  const authSource = await resolveAuthSource(options.cwd);
  if (!authSource) {
    throw new Error(
      `Missing auth source file. Expected: ${path.join("convex", "zenConvex.ts")}`
    );
  }
  if (authSource.layout !== "zen") {
    result.warnings.push(
      `Legacy auth source detected (${authSource.relativePath}). Move to ${path.join("convex", "zenConvex.ts")}.`
    );
  }
  const authSourceContents = await readFile(authSource.absolutePath, "utf8");
  const enabledPlugins = detectEnabledPlugins(authSourceContents);
  const includeOAuth = hasOAuthProviders(authSourceContents);
  const coreAuthImportPath = authSource.coreAuthImportPath;
  const pluginAuthImportPath = authSource.pluginAuthImportPath;

  if (!/export\s+const\s+authOptions\s*=/.test(authSourceContents)) {
    result.warnings.push(
      `authOptions export was not found in ${authSource.relativePath} (recommended for generator compatibility).`
    );
  }

  const filesToGenerate: GeneratedFile[] = [
    {
      absolutePath: path.join(authDir, "core.ts"),
      relativePath: path.join("convex", "auth", "core.ts"),
      content: renderCoreFile({
        includeOAuth,
        authImportPath: coreAuthImportPath,
      }),
    },
  ];
  const generatedPluginSources = new Map<string, string>();

  if (enabledPlugins.has("admin")) {
    const adminContent = renderAdminPluginFile({
      authImportPath: pluginAuthImportPath,
    });
    filesToGenerate.push({
      absolutePath: path.join(pluginDir, "admin.ts"),
      relativePath: path.join("convex", "auth", "plugin", "admin.ts"),
      content: adminContent,
    });
    generatedPluginSources.set("admin", adminContent);
  }

  for (const file of filesToGenerate) {
    await upsertGeneratedFile(file, options, result);
  }

  await deleteGeneratedFileIfExists(
    path.join(authDir, "admin.ts"),
    path.join("convex", "auth", "admin.ts"),
    options,
    result
  );
  if (!enabledPlugins.has("admin")) {
    await deleteGeneratedFileIfExists(
      path.join(pluginDir, "admin.ts"),
      path.join("convex", "auth", "plugin", "admin.ts"),
      options,
      result
    );
  }

  const pluginMeta: PluginFunctionMeta = {};
  for (const [pluginName, source] of generatedPluginSources) {
    const kinds = parsePluginFunctionKinds(source);
    if (Object.keys(kinds).length > 0) {
      pluginMeta[pluginName] = kinds;
    }
  }

  if (await fileExists(pluginDir)) {
    const entries = await readdir(pluginDir, { withFileTypes: true });
    for (const entry of entries) {
      if (!entry.isFile() || !entry.name.endsWith(".ts")) {
        continue;
      }
      if (entry.name === "metaGenerated.ts") {
        continue;
      }
      const pluginName = entry.name.slice(0, -3);
      if (generatedPluginSources.has(pluginName)) {
        continue;
      }

      const absolutePath = path.join(pluginDir, entry.name);
      const source = await readFile(absolutePath, "utf8");
      if (
        pluginName === "admin" &&
        !enabledPlugins.has("admin") &&
        isGeneratedFile(source)
      ) {
        continue;
      }
      const kinds = parsePluginFunctionKinds(source);
      if (Object.keys(kinds).length > 0) {
        pluginMeta[pluginName] = kinds;
      }
    }
  }

  await upsertGeneratedFile(
    {
      absolutePath: path.join(pluginDir, "metaGenerated.ts"),
      relativePath: path.join("convex", "auth", "plugin", "metaGenerated.ts"),
      content: renderPluginMetaFile(pluginMeta),
    },
    options,
    result
  );

  return result;
}
